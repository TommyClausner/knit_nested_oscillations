//! # String Oscillations and Cardioid Pattern Generator
//!
//! This module computes a nested oscillation pattern (in the form of a cardioid) and exports the
//! computed string order to a CSV file. The pattern is defined based on hooks along a circular
//! structure and oscillatory factors that dictate string connections. The implementation supports
//! the use of multiple oscillation factors (how fast the pattern revolves around the circle) and
//! phases (where the first revolution starts).
//!
//! The output is such that the pattern can be strung using a single thread.
//!
//! ## Overview
//! The cardioid pattern is generated by connecting points on a circle based on specific oscillation
//! factors and phases. The algorithm ensures that all points are eventually visited in a systematic
//! order. The result is written to a CSV file for further processing or visualization.
//!
//! ### Terminology
//! - **Hooks**: Points along the circumference of the circle.
//! - **Oscillation Factors**: Determines how far each string "jumps" when connecting points (e.g.
//!   a factor of two would double the hook index at each step).
//! - **Phases**: Offsets applied to the oscillation factors to introduce variation in the pattern.
//!   Phases are expressed as fractions of the circle's circumference (e.g., 0.5 corresponds to Ï€
//!   offset)
//! - **Cardioid**: The final sequence of connected strings forming a nested oscillatory pattern.
//!
//! ## Example Usage
//! ```rust
//! use knit_nested_oscillations::{make_cardioid, Settings};
//!
//! let settings = Settings {
//!     n_hooks: 500, // Number of hooks on the circle
//!     osc_factors: vec![2, 3, 4], // Oscillation factors (length must match osc_phases)
//!     osc_phases: vec![0.1, 0.3, 0.7], // Phases corresponding to the oscillation factors
//!     output_file: "output.csv".to_string(), // Output file for the computed string order
//! };
//!
//! let string_order = make_cardioid(&settings);
//! println!("{:?}", string_order); // Prints the computed string order
//! ```
//!
//! ## Output
//! The program outputs the computed string order to the specified CSV file. Each row in the file
//! corresponds to a point in the pattern, representing its index in the sequence of points around
//! the circle.
//!
//! The output CSV contains the string connections in the following format:
//! ```csv
//! index, from, to
//! 0, 1, 42
//! 1, 42, 7
//! ...
//! ```
//!
//! ## Display Results
//! The easiest would be to display results using **Python**:
//!
//! ```python
//! import numpy as np
//! import matplotlib.pyplot as plt
//!
//! num_hooks = 500  # must be equal to what has been set before
//!
//! # Compute circle coordinates
//! theta = np.linspace(0, 2 * np.pi, num_hooks)
//! circle = np.asarray([np.cos(theta), np.sin(theta)]).T
//!
//! # load data
//! data = np.genfromtxt('output.csv', delimiter=',', dtype=int)
//!
//! # Use data to index circle coordinates
//! for (_, d_from, d_to) in data:
//!     plt.plot([circle[d_from, 0], circle[d_to, 0]],
//!              [circle[d_from, 1], circle[d_to, 1]], color="k", linewidth=0.1)
//!
//! # Cosmetics
//! plt.axis('equal')
//! plt.axis('off')
//! plt.tight_layout()
//! plt.gca().invert_yaxis()
//! plt.show()
//! ```

use csv::Writer;
use serde::Serialize;
use std::error::Error;
use std::fmt::Debug;
use std::path::Path;
use std::str::FromStr;

/// Settings structure for stringing algorithm
///
/// Fields:
/// - **n_hooks**: The number of points to divide the circle.
/// - **osc_factors**: Multiplication factor(s) of the stringing. A string is defined as
///   `(idx, (idx * osc_factors) % n)`. If more than one value, the stringing pattern will nest
///   the different oscillations.
/// - **osc_phases**: Phase of per oscillation. Values can range from 0 to 1, where 0 is no offset
///   and 1 describes the full circle (i.e. no offset). In turn, 0.5 would correspond to an offset
///   of PI.
/// - **output_file**: The file to write the output to.
#[derive(Debug)]
pub struct Settings {
    pub n_hooks: i32,
    pub osc_factors: Vec<i32>,
    pub osc_phases: Vec<f64>,
    pub output_file: String,
}

impl Settings {
    pub fn new(mut args: impl Iterator<Item = String>) -> Result<Settings, &'static str> {
        args.next();

        let output_file = match args.next() {
            Some(arg) => arg,
            None => return Err("Missing output file"),
        };

        let n_hooks = args
            .next()
            .unwrap_or_else(|| "500".parse().unwrap())
            .parse::<i32>()
            .unwrap();

        let osc_factors: Vec<i32> =
            parse_values_to_vec(&args.next().unwrap_or_else(|| "2".parse().unwrap()));

        let osc_phases: Vec<f64> = parse_values_to_vec(&args.next().unwrap_or_else(|| {
            std::iter::repeat("0.0".to_string())
                .take(osc_factors.len())
                .collect::<Vec<_>>()
                .join(",")
                .parse()
                .unwrap()
        }));

        Ok(Settings {
            n_hooks,
            osc_factors,
            osc_phases,
            output_file,
        })
    }
}

/// Function to compute the cardioid
///
/// Takes [`Settings`] as input.
pub fn make_cardioid(settings: &Settings) -> Vec<(i32, i32, i32)> {
    let n = settings.n_hooks;
    let spacings = &settings.osc_factors;
    let phases = &settings.osc_phases;

    // Make all cardioid strings and initialize cardioid with first string
    let mut strings = cardioid_strings(n, &spacings, &phases);
    let mut cardioid = vec![strings[0]];

    strings.remove(0);

    // While still unused cardioid strings compute logic
    while strings.len() > 1 {
        let hook = cardioid.last().unwrap().1;

        // The Next string is either from the set of cardioid strings or a single step to a
        // neighboring hook
        let string = get_string(strings.clone(), hook, n);
        if !cardioid.contains(&string) {
            cardioid.push(string);
        } else {
            cardioid.push((hook, (hook + 1) % n));
        }

        // If string added was from set of cardioid strings, remove from set. Otherwise: continue
        match get_index(&strings, string) {
            Some(idx) => {
                strings.remove(idx);
            }
            None => continue,
        };
    }
    let output = get_string_order(cardioid);

    let file_path = Path::new(&settings.output_file);
    let _ = cardioid_to_csv(file_path, &output);
    println!("Saved to: {}", file_path.display());
    output
    //cardioid
}

fn cardioid_strings(n: i32, spacings: &Vec<i32>, phases: &Vec<f64>) -> Vec<(i32, i32)> {
    let phases: Vec<i32> = phases
        .iter()
        .map(|p| (p * n as f64).round() as i32)
        .collect();

    (1..=n)
        .flat_map(|n_i| {
            spacings.clone().into_iter().enumerate().map({
                let phases = phases.clone();
                move |(i, s)| ((n_i + phases[i]) % n, ((n_i * s) + phases[i]) % n)
            })
        })
        .filter(|&(i, j)| i != j)
        .collect()
}

fn get_string(strings: Vec<(i32, i32)>, hook: i32, n: i32) -> (i32, i32) {
    strings
        .into_iter()
        .filter(|s| s.0 == hook)
        .collect::<Vec<_>>()
        .first()
        .unwrap_or(&(hook, (hook + 1) % n))
        .clone()
}

fn get_index(strings: &Vec<(i32, i32)>, candidate: (i32, i32)) -> Option<usize> {
    strings.iter().position(|&x| x == candidate)
}

fn get_string_order(cardioid: Vec<(i32, i32)>) -> Vec<(i32, i32, i32)> {
    cardioid
        .iter()
        .enumerate()
        .map(|(i, p)| (i as i32, p.0, p.1))
        .collect()
}

fn parse_values_to_vec<T>(input: &str) -> Vec<T>
where
    T: FromStr,
    <T as FromStr>::Err: Debug, // T must implement the FromStr trait
{
    input
        .split(',')
        .map(|s| s.trim().parse().unwrap())
        .collect()
}

fn cardioid_to_csv<T: Serialize>(filename: &Path, data: &Vec<T>) -> Result<(), Box<dyn Error>> {
    let mut writer = Writer::from_path(filename)?;

    for item in data {
        writer.serialize(item)?;
    }
    writer.flush()?;
    Ok(())
}
